let W;(typeof navigator>"u"||!navigator.userAgent?.startsWith?.("Mozilla/5.0 "))&&(W="oauth4webapi/v1.2.0");const ae=new TextEncoder,ce=new TextDecoder;function y(e){return"string"==typeof e?ae.encode(e):ce.decode(e)}const B=32768;function ue(e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));const t=[];for(let n=0;n<e.byteLength;n+=B)t.push(String.fromCharCode.apply(null,e.subarray(n,n+B)));return btoa(t.join("")).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function pe(e){try{const t=atob(e.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"")),n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t.charCodeAt(r);return n}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}function b(e){return"string"==typeof e?pe(e):ue(e)}class V{constructor(t){this.cache=new Map,this._cache=new Map,this.maxSize=t}get(t){let n=this.cache.get(t);return n||((n=this._cache.get(t))?(this.update(t,n),n):void 0)}has(t){return this.cache.has(t)||this._cache.has(t)}set(t,n){return this.cache.has(t)?this.cache.set(t,n):this.update(t,n),this}delete(t){return this.cache.has(t)?this.cache.delete(t):!!this._cache.has(t)&&this._cache.delete(t)}update(t,n){this.cache.set(t,n),this.cache.size>=this.maxSize&&(this._cache=this.cache,this.cache=new Map)}}export class UnsupportedOperationError extends Error{constructor(t){super(t??"operation not supported"),this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}export class OperationProcessingError extends Error{constructor(t){super(t),this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}const i=OperationProcessingError,Z=new V(100);function X(e){return e instanceof CryptoKey}function N(e){return X(e)&&"private"===e.type}function F(e){return X(e)&&"public"===e.type}const de=["PS256","ES256","RS256","EdDSA"];function g(e){return Ce(e),e.clone()}function P(e){const t=new URL(e.url);return e.headers.has("dpop-nonce")&&Z.set(t.origin,e.headers.get("dpop-nonce")),e}function fe(e){return e.toLowerCase().replace(/^application\//,"")}function m(e){return!(null===e||"object"!=typeof e||Array.isArray(e))}function k(e){if(void 0!==e&&!(e instanceof Headers))throw new TypeError('"options.headers" must be an instance of Headers');const t=new Headers(e);if(W&&!t.has("user-agent")&&t.set("user-agent",W),t.has("authorization"))throw new TypeError('"options.headers" must not include the "authorization" header name');if(t.has("dpop"))throw new TypeError('"options.headers" must not include the "dpop" header name');return t}function j(e){return"function"==typeof e?e():e}export async function discoveryRequest(e,t){if(!(e instanceof URL))throw new TypeError('"issuer" must be an instance of URL');if("https:"!==e.protocol&&"http:"!==e.protocol)throw new TypeError('"issuer.protocol" must be "https:" or "http:"');const n=new URL(e.href);switch(t?.algorithm){case void 0:case"oidc":n.pathname=`${n.pathname}/.well-known/openid-configuration`.replace("//","/");break;case"oauth2":n.pathname="/"===n.pathname?".well-known/oauth-authorization-server":`.well-known/oauth-authorization-server/${n.pathname}`.replace("//","/");break;default:throw new TypeError('"options.algorithm" must be "oidc" (default), or "oauth2"')}const r=k(t?.headers);return r.set("accept","application/json"),fetch(n.href,{headers:r,method:"GET",redirect:"manual",signal:t?.signal?j(t.signal):null}).then(P)}function p(e){return"string"==typeof e&&0!==e.length}export async function processDiscoveryResponse(e,t){if(!(e instanceof URL))throw new TypeError('"expectedIssuer" must be an instance of URL');if(!(t instanceof Response))throw new TypeError('"response" must be an instance of Response');if(200!==t.status)throw new i('"response" is not a conform Authorization Server Metadata response');let n;try{n=await g(t).json()}catch{throw new i('failed to parse "response" body as JSON')}if(!m(n))throw new i('"response" body must be a top level object');if(!p(n.issuer))throw new i('"response" body "issuer" property must be a non-empty string');if(new URL(n.issuer).href!==e.href)throw new i('"response" body "issuer" does not match "expectedIssuer"');return n}function R(){return b(crypto.getRandomValues(new Uint8Array(32)))}export function generateRandomCodeVerifier(){return R()}export function generateRandomState(){return R()}export function generateRandomNonce(){return R()}export async function calculatePKCECodeChallenge(e){if(!p(e))throw new TypeError('"codeVerifier" must be a non-empty string');return b(await crypto.subtle.digest({name:"SHA-256"},y(e)))}function Q(e){if(e instanceof CryptoKey)return{key:e};if(!(e?.key instanceof CryptoKey))return{};if(void 0!==e.kid&&!p(e.kid))throw new TypeError('"kid" must be a non-empty string');return{key:e.key,kid:e.kid}}function Y(e){return encodeURIComponent(e).replace(/%20/g,"+")}function he(e,t){const n=Y(e),r=Y(t);return`Basic ${btoa(`${n}:${r}`)}`}function we(e){if("SHA-256"===e.algorithm.hash.name)return"PS256";throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name")}function le(e){if("SHA-256"===e.algorithm.hash.name)return"RS256";throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name")}function ye(e){if("P-256"===e.algorithm.namedCurve)return"ES256";throw new UnsupportedOperationError("unsupported EcKeyAlgorithm namedCurve")}function J(e){switch(e.algorithm.name){case"RSA-PSS":return we(e);case"RSASSA-PKCS1-v1_5":return le(e);case"ECDSA":return ye(e);case"Ed25519":return"EdDSA";default:throw new UnsupportedOperationError("unsupported CryptoKey algorithm name")}}function S(){return Math.floor(Date.now()/1e3)}function me(e,t){const n=S();return{jti:R(),aud:[e.issuer,e.token_endpoint],exp:n+60,iat:n,nbf:n,iss:t.client_id,sub:t.client_id}}async function be(e,t,n,r){return $({alg:J(n),kid:r},me(e,t),n)}function f(e){if("object"!=typeof e||null===e)throw new TypeError('"issuer" must be an object');if(!p(e.issuer))throw new TypeError('"issuer.issuer" property must be a non-empty string');return!0}function h(e){if("object"!=typeof e||null===e)throw new TypeError('"client" must be an object');if(!p(e.client_id))throw new TypeError('"client.client_id" property must be a non-empty string');return!0}function ee(e){if(!p(e))throw new TypeError('"client.client_secret" property must be a non-empty string');return e}function q(e,t){if(void 0!==t)throw new TypeError(`"options.clientPrivateKey" property must not be provided when ${e} client authentication method is used.`)}function te(e,t){if(void 0!==t)throw new TypeError(`"client.client_secret" property must not be provided when ${e} client authentication method is used.`)}async function ge(e,t,n,r,o){switch(n.delete("client_secret"),n.delete("client_assertion_type"),n.delete("client_assertion"),t.token_endpoint_auth_method){case void 0:case"client_secret_basic":q("client_secret_basic",o),r.set("authorization",he(t.client_id,ee(t.client_secret)));break;case"client_secret_post":q("client_secret_post",o),n.set("client_id",t.client_id),n.set("client_secret",ee(t.client_secret));break;case"private_key_jwt":{if(te("private_key_jwt",t.client_secret),void 0===o)throw new TypeError('"options.clientPrivateKey" must be provided when "client.token_endpoint_auth_method" is "private_key_jwt"');const{key:a,kid:s}=Q(o);if(!N(a))throw new TypeError('"options.clientPrivateKey.key" must be a private CryptoKey');n.set("client_id",t.client_id),n.set("client_assertion_type","urn:ietf:params:oauth:client-assertion-type:jwt-bearer"),n.set("client_assertion",await be(e,t,a,s));break}case"none":te("none",t.client_secret),q("none",o),n.set("client_id",t.client_id);break;default:throw new UnsupportedOperationError("unsupported client token_endpoint_auth_method")}}async function $(e,t,n){if(!n.usages.includes("sign"))throw new TypeError('private CryptoKey instances used for signing assertions must include "sign" in their "usages"');const r=`${b(y(JSON.stringify(e)))}.${b(y(JSON.stringify(t)))}`;return`${r}.${b(await crypto.subtle.sign(ie(n),n,y(r)))}`}export async function issueRequestObject(e,t,n,r){if(f(e),h(t),!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams');n=new URLSearchParams(n);const{key:o,kid:a}=Q(r);if(!N(o))throw new TypeError('"privateKey.key" must be a private CryptoKey');n.set("client_id",t.client_id);const s=S(),c={...Object.fromEntries(n.entries()),jti:R(),aud:e.issuer,exp:s+60,iat:s,nbf:s,iss:t.client_id};let u;return n.has("resource")&&(u=n.getAll("resource"))&&u.length>1&&(c.resource=u),$({alg:J(o),typ:"oauth-authz-req+jwt",kid:a},c,o)}async function H(e,t,n,r,o){const{privateKey:a,publicKey:s,nonce:c=Z.get(n.origin)}=t;if(!N(a))throw new TypeError('"DPoP.privateKey" must be a private CryptoKey');if(!F(s))throw new TypeError('"DPoP.publicKey" must be a public CryptoKey');if(void 0!==c&&!p(c))throw new TypeError('"DPoP.nonce" must be a non-empty string or undefined');if(!s.extractable)throw new TypeError('"DPoP.publicKey.extractable" must be true');const u=S(),w=await $({alg:J(a),typ:"dpop+jwt",jwk:await _e(s)},{iat:u,jti:R(),htm:r,nonce:c,htu:`${n.origin}${n.pathname}`,ath:o?b(await crypto.subtle.digest({name:"SHA-256"},y(o))):void 0},a);e.set("dpop",w)}async function _e(e){const{kty:t,e:n,n:r,x:o,y:a,crv:s}=await crypto.subtle.exportKey("jwk",e);return{kty:t,crv:s,e:n,n:r,x:o,y:a}}export async function pushedAuthorizationRequest(e,t,n,r){if(f(e),h(t),!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams');if("string"!=typeof e.pushed_authorization_request_endpoint)throw new TypeError('"issuer.pushed_authorization_request_endpoint" must be a string');const o=new URL(e.pushed_authorization_request_endpoint),a=new URLSearchParams(n);a.set("client_id",t.client_id);const s=k(r?.headers);return s.set("accept","application/json"),void 0!==r?.DPoP&&(await H(s,r.DPoP,o,"POST"),a.has("dpop_jkt")||a.set("dpop_jkt",await calculateJwkThumbprint(r.DPoP.publicKey))),v(e,t,"POST",o,a,s,r)}export function isOAuth2Error(e){const t=e;return"object"==typeof t&&!Array.isArray(t)&&null!==t&&void 0!==t.error}function ke(e){return e.length>=2&&'"'===e[0]&&'"'===e[e.length-1]?e.slice(1,-1):e}const Se=/((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/,Re=/(?:^|, ?)([0-9a-zA-Z!#$%&'*+\-.^_`|~]+)(?=$|[ ,])/g;function Ee(e,t){const n=t.split(Se).slice(1);if(!n.length)return{scheme:e.toLowerCase(),parameters:{}};n[n.length-1]=n[n.length-1].replace(/,$/,"");const r={};for(let o=1;o<n.length;o+=2){const a=o;if('"'===n[a][0])for(;'"'!==n[a].slice(-1)&&++o<n.length;)n[a]+=n[o];r[n[a-1].replace(/^(?:, ?)|=$/g,"").toLowerCase()]=ke(n[a])}return{scheme:e.toLowerCase(),parameters:r}}export function parseWwwAuthenticateChallenges(e){if(!(e instanceof Response))throw new TypeError('"response" must be an instance of Response');if(!e.headers.has("www-authenticate"))return;const t=e.headers.get("www-authenticate"),n=[];for(const{1:o,index:a}of t.matchAll(Re))n.push([o,a]);return n.length?n.map(([o,a],s,c)=>{const u=c[s+1];let w;return w=u?t.slice(a,u[1]):t.slice(a),Ee(o,w)}):void 0}export async function processPushedAuthorizationResponse(e,t,n){if(f(e),h(t),!(n instanceof Response))throw new TypeError('"response" must be an instance of Response');if(201!==n.status){let o;if(o=await A(n))return o;throw new i('"response" is not a conform Pushed Authorization Request Endpoint response')}let r;try{r=await g(n).json()}catch{throw new i('failed to parse "response" body as JSON')}if(!m(r))throw new i('"response" body must be a top level object');if(!p(r.request_uri))throw new i('"response" body "request_uri" property must be a non-empty string');if("number"!=typeof r.expires_in||r.expires_in<=0)throw new i('"response" body "expires_in" property must be a positive number');return r}export async function protectedResourceRequest(e,t,n,r,o,a){if(!p(e))throw new TypeError('"accessToken" must be a non-empty string');if(!(n instanceof URL))throw new TypeError('"url" must be an instance of URL');return r=k(r),void 0===a?.DPoP?r.set("authorization",`Bearer ${e}`):(await H(r,a.DPoP,n,"GET",e),r.set("authorization",`DPoP ${e}`)),fetch(n.href,{body:o,headers:r,method:t,redirect:"manual",signal:a?.signal?j(a.signal):null}).then(P)}export async function userInfoRequest(e,t,n,r){if(f(e),h(t),"string"!=typeof e.userinfo_endpoint)throw new TypeError('"issuer.userinfo_endpoint" must be a string');const o=new URL(e.userinfo_endpoint),a=k(r?.headers);return t.userinfo_signed_response_alg?a.set("accept","application/jwt"):(a.set("accept","application/json"),a.append("accept","application/jwt")),protectedResourceRequest(n,"GET",o,a,null,r)}const T=new V(20),C={};async function E(e,t,n){const{alg:r,kid:o}=n;let a,s,c;if(Ue(r),T.has(e.jwks_uri)){if(({jwks:a,age:s}=T.get(e.jwks_uri)),s>=300)return T.delete(e.jwks_uri),E(e,t,n)}else a=await jwksRequest(e,t).then(processJwksResponse),s=0,T.set(e.jwks_uri,{jwks:a,iat:S(),get age(){return S()-this.iat}});switch(r.slice(0,2)){case"RS":case"PS":c="RSA";break;case"ES":c="EC";break;case"Ed":c="OKP";break;default:throw new UnsupportedOperationError}const u=a.keys.filter(l=>{if(l.kty!==c||void 0!==o&&o!==l.kid||void 0!==l.alg&&r!==l.alg||void 0!==l.use&&"sig"!==l.use||!1===l.key_ops?.includes("verify"))return!1;switch(!0){case"ES256"===r&&"P-256"!==l.crv:case"EdDSA"===r&&"Ed25519"!==l.crv:return!1}return!0}),{0:w,length:z}=u;if(!z){if(s>=60)return T.delete(e.jwks_uri),E(e,t,n);throw new i("error when selecting a JWT verification key, no applicable keys found")}if(1!==z)throw new i('error when selecting a JWT verification key, multiple applicable keys found, a "kid" JWT Header Parameter is required');C[r]||(C[r]=new WeakMap);let d=C[r].get(w);if(!d){if(d=await Le({...w,alg:r}),"public"!==d.type)throw new i("jwks_uri must only contain public keys");C[r].set(w,d)}return d}export const skipSubjectCheck=Symbol();function ne(e){return e.headers.get("content-type")?.split(";")[0]}export async function processUserInfoResponse(e,t,n,r,o){if(f(e),h(t),!(r instanceof Response))throw new TypeError('"response" must be an instance of Response');if(200!==r.status)throw new i('"response" is not a conform UserInfo Endpoint response');let a;if("application/jwt"===ne(r)){if("string"!=typeof e.jwks_uri)throw new TypeError('"issuer.jwks_uri" must be a string');const{claims:s}=await O(await g(r).text(),D.bind(void 0,t.userinfo_signed_response_alg,e.userinfo_signing_alg_values_supported),E.bind(void 0,e,o)).then(Ae.bind(void 0,t.client_id)).then(Pe.bind(void 0,e.issuer));a=s}else{if(t.userinfo_signed_response_alg)throw new i("JWT UserInfo Response expected");try{a=await g(r).json()}catch{throw new i('failed to parse "response" body as JSON')}}if(!m(a))throw new i('"response" body must be a top level object');if(!p(a.sub))throw new i('"response" body "sub" property must be a non-empty string');if(n===skipSubjectCheck);else{if(!p(n))throw new i('"expectedSubject" must be a non-empty string');if(a.sub!==n)throw new i('unexpected "response" body "sub" value')}return a}function re(e,t){const n=new Uint8Array(t);return n.set(e),n}function Te(e,t){const n=Math.max(e.byteLength,t.byteLength);e=re(e,n),t=re(t,n);let r=0,o=-1;for(;++o<n;)r|=e[o]^t[o];return 0===r}async function ve(e,t){let n;switch(e){case"RS256":case"PS256":case"ES256":n={name:"SHA-256"};break;case"EdDSA":n={name:"SHA-512"};break;default:throw new UnsupportedOperationError}const r=await crypto.subtle.digest(n,y(t));return b(r.slice(0,r.byteLength/2))}async function xe(e,t,n){const r=await ve(e,t);return Te(y(n),y(r))}async function v(e,t,n,r,o,a,s){return await ge(e,t,o,a,s?.clientPrivateKey),fetch(r.href,{body:o,headers:a,method:n,redirect:"manual",signal:s?.signal?j(s.signal):null}).then(P)}async function U(e,t,n,r,o){if("string"!=typeof e.token_endpoint)throw new TypeError('"issuer.token_endpoint" must be a string');const a=new URL(e.token_endpoint);r.set("grant_type",n);const s=k(o?.headers);return s.set("accept","application/json"),void 0!==o?.DPoP&&await H(s,o.DPoP,a,"POST"),v(e,t,"POST",a,r,s,o)}export async function refreshTokenGrantRequest(e,t,n,r){if(f(e),h(t),!p(n))throw new TypeError('"refreshToken" must be a non-empty string');const o=new URLSearchParams(r?.additionalParameters);return o.set("refresh_token",n),U(e,t,"refresh_token",o,r)}const I=new WeakMap;export function getValidatedIdTokenClaims(e){if(!I.has(e))throw new TypeError('"ref" was already garbage collected or did not resolve from the proper sources');return I.get(e)}async function x(e,t,n,r,o=!1,a=!1){if(f(e),h(t),!(n instanceof Response))throw new TypeError('"response" must be an instance of Response');if(200!==n.status){let c;if(c=await A(n))return c;throw new i('"response" is not a conform Token Endpoint response')}let s;try{s=await g(n).json()}catch{throw new i('failed to parse "response" body as JSON')}if(!m(s))throw new i('"response" body must be a top level object');if(!p(s.access_token))throw new i('"response" body "access_token" property must be a non-empty string');if(!p(s.token_type))throw new i('"response" body "token_type" property must be a non-empty string');if(s.token_type=s.token_type.toLowerCase(),"dpop"!==s.token_type&&"bearer"!==s.token_type)throw new UnsupportedOperationError("unsupported `token_type` value");if(void 0!==s.expires_in&&("number"!=typeof s.expires_in||s.expires_in<=0))throw new i('"response" body "expires_in" property must be a positive number');if(!a&&void 0!==s.refresh_token&&!p(s.refresh_token))throw new i('"response" body "refresh_token" property must be a non-empty string');if(void 0!==s.scope&&"string"!=typeof s.scope)throw new i('"response" body "scope" property must be a string');if(!o){if(void 0!==s.id_token&&!p(s.id_token))throw new i('"response" body "id_token" property must be a non-empty string');if(s.id_token){if("string"!=typeof e.jwks_uri)throw new TypeError('"issuer.jwks_uri" must be a string');const{header:c,claims:u}=await O(s.id_token,D.bind(void 0,t.id_token_signed_response_alg,e.id_token_signing_alg_values_supported),E.bind(void 0,e,r)).then(M.bind(void 0,["aud","exp","iat","iss","sub"])).then(K.bind(void 0,e.issuer)).then(L.bind(void 0,t.client_id));if(Array.isArray(u.aud)&&1!==u.aud.length&&u.azp!==t.client_id)throw new i('unexpected ID Token "azp" (authorized party) claim value');if(t.require_auth_time&&"number"!=typeof u.auth_time)throw new i('unexpected ID Token "auth_time" (authentication time) claim value');if(void 0!==u.at_hash&&("string"!=typeof u.at_hash||!await xe(c.alg,s.access_token,u.at_hash)))throw new i('unexpected ID Token "at_hash" (access token hash) claim value');I.set(s,u)}}return s}export async function processRefreshTokenResponse(e,t,n,r){return x(e,t,n,r)}function Ae(e,t){return void 0!==t.claims.aud?L(e,t):t}function L(e,t){if(Array.isArray(t.claims.aud)){if(!t.claims.aud.includes(e))throw new i('unexpected JWT "aud" (audience) claim value')}else if(t.claims.aud!==e)throw new i('unexpected JWT "aud" (audience) claim value');return t}function Pe(e,t){return void 0!==t.claims.iss?K(e,t):t}function K(e,t){if(t.claims.iss!==e)throw new i('unexpected JWT "iss" (issuer) claim value');return t}export async function authorizationCodeGrantRequest(e,t,n,r,o,a){if(f(e),h(t),!(n instanceof se))throw new TypeError('"callbackParameters" must be an instance of CallbackParameters obtained from "validateAuthResponse()", or "validateJwtAuthResponse()');if(!p(r))throw new TypeError('"redirectUri" must be a non-empty string');if(!p(o))throw new TypeError('"codeVerifier" must be a non-empty string');const s=_(n,"code");if(!s)throw new i('no authorization code in "callbackParameters"');const c=new URLSearchParams(a?.additionalParameters);return c.set("redirect_uri",r),c.set("code_verifier",o),c.set("code",s),U(e,t,"authorization_code",c,a)}const je={aud:"audience",exp:"expiration time",iat:"issued at",iss:"issuer",sub:"subject"};function M(e,t){for(const n of e)if(void 0===t.claims[n])throw new i(`JWT "${n}" (${je[n]}) claim missing`);return t}export const expectNoNonce=Symbol(),skipAuthTimeCheck=Symbol();export async function processAuthorizationCodeOpenIDResponse(e,t,n,r,o,a){const s=await x(e,t,n,a);if(isOAuth2Error(s))return s;if(!p(s.id_token))throw new i('"response" body "id_token" property must be a non-empty string');o??(o=t.default_max_age??skipAuthTimeCheck);const c=getValidatedIdTokenClaims(s);if((t.require_auth_time||o!==skipAuthTimeCheck)&&void 0===c.auth_time)throw new i('ID Token "auth_time" (authentication time) claim missing');if(o!==skipAuthTimeCheck){if("number"!=typeof o||o<0)throw new TypeError('"options.max_age" must be a non-negative number');const u=S();if(c.auth_time+o<u-30)throw new i("too much time has elapsed since the last End-User authentication")}switch(r){case void 0:case expectNoNonce:if(void 0!==c.nonce)throw new i('unexpected ID Token "nonce" claim value');break;default:if(!p(r))throw new TypeError('"expectedNonce" must be a non-empty string');if(void 0===c.nonce)throw new i('ID Token "nonce" claim missing');if(c.nonce!==r)throw new i('unexpected ID Token "nonce" claim value')}return s}export async function processAuthorizationCodeOAuth2Response(e,t,n){const r=await x(e,t,n,void 0,!0);if(isOAuth2Error(r))return r;if(void 0!==r.id_token){if("string"==typeof r.id_token&&r.id_token.length)throw new i("Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing");delete r.id_token}return r}function Je(e,t){if("string"!=typeof t.header.typ||fe(t.header.typ)!==e)throw new i('unexpected JWT "typ" header parameter value');return t}export async function clientCredentialsGrantRequest(e,t,n,r){return f(e),h(t),U(e,t,"client_credentials",new URLSearchParams(n),r)}export async function processClientCredentialsResponse(e,t,n){const r=await x(e,t,n,void 0,!0,!0);return isOAuth2Error(r),r}export async function revocationRequest(e,t,n,r){if(f(e),h(t),!p(n))throw new TypeError('"token" must be a non-empty string');if("string"!=typeof e.revocation_endpoint)throw new TypeError('"issuer.revocation_endpoint" must be a string');const o=new URL(e.revocation_endpoint),a=new URLSearchParams(r?.additionalParameters);a.set("token",n);const s=k(r?.headers);return s.delete("accept"),v(e,t,"POST",o,a,s,r)}export async function processRevocationResponse(e){if(!(e instanceof Response))throw new TypeError('"response" must be an instance of Response');if(200!==e.status){let t;if(t=await A(e))return t;throw new i('"response" is not a conform Revocation Endpoint response')}}function Ce(e){if(e.bodyUsed)throw new TypeError('"response" body has been used already')}export async function introspectionRequest(e,t,n,r){if(f(e),h(t),!p(n))throw new TypeError('"token" must be a non-empty string');if("string"!=typeof e.introspection_endpoint)throw new TypeError('"issuer.introspection_endpoint" must be a string');const o=new URL(e.introspection_endpoint),a=new URLSearchParams(r?.additionalParameters);a.set("token",n);const s=k(r?.headers);return s.set("accept",r?.requestJwtResponse??t.introspection_signed_response_alg?"application/token-introspection+jwt":"application/json"),v(e,t,"POST",o,a,s,r)}export async function processIntrospectionResponse(e,t,n,r){if(f(e),h(t),!(n instanceof Response))throw new TypeError('"response" must be an instance of Response');if(200!==n.status){let a;if(a=await A(n))return a;throw new i('"response" is not a conform Introspection Endpoint response')}let o;if("application/token-introspection+jwt"===ne(n)){if("string"!=typeof e.jwks_uri)throw new TypeError('"issuer.jwks_uri" must be a string');const{claims:a}=await O(await g(n).text(),D.bind(void 0,t.introspection_signed_response_alg,e.introspection_signing_alg_values_supported),E.bind(void 0,e,r)).then(Je.bind(void 0,"token-introspection+jwt")).then(M.bind(void 0,["aud","iat","iss"])).then(K.bind(void 0,e.issuer)).then(L.bind(void 0,t.client_id));if(o=a.token_introspection,!m(o))throw new i('JWT "token_introspection" claim must be a JSON object')}else{try{o=await g(n).json()}catch{throw new i('failed to parse "response" body as JSON')}if(!m(o))throw new i('"response" body must be a top level object')}if("boolean"!=typeof o.active)throw new i('"response" body "active" property must be a boolean');return o}export async function jwksRequest(e,t){if(f(e),"string"!=typeof e.jwks_uri)throw new TypeError('"issuer.jwks_uri" must be a string');const n=new URL(e.jwks_uri),r=k(t?.headers);return r.set("accept","application/json"),r.append("accept","application/jwk-set+json"),fetch(n.href,{headers:r,method:"GET",redirect:"manual",signal:t?.signal?j(t.signal):null}).then(P)}export async function processJwksResponse(e){if(!(e instanceof Response))throw new TypeError('"response" must be an instance of Response');if(200!==e.status)throw new i('"response" is not a conform JSON Web Key Set response');let t;try{t=await g(e).json()}catch{throw new i('failed to parse "response" body as JSON')}if(!m(t))throw new i('"response" body must be a top level object');if(!Array.isArray(t.keys))throw new i('"response" body "keys" property must be an array');if(!Array.prototype.every.call(t.keys,m))throw new i('"response" body "keys" property members must be JWK formatted objects');return t}async function A(e){if(e.status>399&&e.status<500)try{const t=await g(e).json();if(m(t)&&"string"==typeof t.error&&t.error.length)return void 0!==t.error_description&&"string"!=typeof t.error_description&&delete t.error_description,void 0!==t.error_uri&&"string"!=typeof t.error_uri&&delete t.error_uri,void 0!==t.algs&&"string"!=typeof t.algs&&delete t.algs,void 0!==t.scope&&"string"!=typeof t.scope&&delete t.scope,t}catch{}}function Ue(e){if(!de.includes(e))throw new UnsupportedOperationError('unsupported JWS "alg" identifier');return e}function oe(e){if("number"!=typeof e.modulusLength||e.modulusLength<2048)throw new i(`${e.name} modulusLength must be at least 2048 bits`)}function ie(e){switch(e.algorithm.name){case"ECDSA":return{name:e.algorithm.name,hash:{name:"SHA-256"}};case"RSA-PSS":return oe(e.algorithm),{name:e.algorithm.name,saltLength:32};case"RSASSA-PKCS1-v1_5":return oe(e.algorithm),{name:e.algorithm.name};case"Ed25519":return{name:e.algorithm.name}}throw new UnsupportedOperationError}async function O(e,t,n){const{0:r,1:o,2:a,length:s}=e.split(".");if(5===s)throw new UnsupportedOperationError("JWE structure JWTs are not supported");if(3!==s)throw new i("Invalid JWT");let c;try{c=JSON.parse(y(b(r)))}catch{throw new i("failed to parse JWT Header body as base64url encoded JSON")}if(!m(c))throw new i("JWT Header must be a top level object");if(t(c),void 0!==c.crit)throw new i('unexpected JWT "crit" header parameter');const u=await n(c),w=`${r}.${o}`;if(!await crypto.subtle.verify(ie(u),u,b(a),y(w)))throw new i("JWT signature verification failed");let d;try{d=JSON.parse(y(b(o)))}catch{throw new i("failed to parse JWT Payload body as base64url encoded JSON")}if(!m(d))throw new i("JWT Payload must be a top level object");const l=S();if(void 0!==d.exp){if("number"!=typeof d.exp)throw new i('unexpected JWT "exp" (expiration time) claim type');if(d.exp<=l-30)throw new i('unexpected JWT "exp" (expiration time) claim value, timestamp is <= now()')}if(void 0!==d.iat&&"number"!=typeof d.iat)throw new i('unexpected JWT "iat" (issued at) claim type');if(void 0!==d.iss&&"string"!=typeof d.iss)throw new i('unexpected JWT "iss" (issuer) claim type');if(void 0!==d.nbf){if("number"!=typeof d.nbf)throw new i('unexpected JWT "nbf" (not before) claim type');if(d.nbf>l+30)throw new i('unexpected JWT "nbf" (not before) claim value, timestamp is > now()')}if(void 0!==d.aud&&"string"!=typeof d.aud&&!Array.isArray(d.aud))throw new i('unexpected JWT "aud" (audience) claim type');return{header:c,claims:d}}export async function validateJwtAuthResponse(e,t,n,r,o){if(f(e),h(t),n instanceof URL&&(n=n.searchParams),!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams, or URL');const a=_(n,"response");if(!a)throw new i('"parameters" does not contain a JARM response');if("string"!=typeof e.jwks_uri)throw new TypeError('"issuer.jwks_uri" must be a string');const{claims:s}=await O(a,D.bind(void 0,t.authorization_signed_response_alg,e.authorization_signing_alg_values_supported),E.bind(void 0,e,o)).then(M.bind(void 0,["aud","exp","iss"])).then(K.bind(void 0,e.issuer)).then(L.bind(void 0,t.client_id)),c=new URLSearchParams;for(const[u,w]of Object.entries(s))"string"==typeof w&&"aud"!==u&&c.set(u,w);return validateAuthResponse(e,t,c,r)}function D(e,t,n){if(void 0===e){if(Array.isArray(t)){if(!t.includes(n.alg))throw new i('unexpected JWT "alg" header parameter')}else if("RS256"!==n.alg)throw new i('unexpected JWT "alg" header parameter')}else if(n.alg!==e)throw new i('unexpected JWT "alg" header parameter')}function _(e,t){const{0:n,length:r}=e.getAll(t);if(r>1)throw new i(`"${t}" parameter must be provided only once`);return n}export const skipStateCheck=Symbol(),expectNoState=Symbol();class se extends URLSearchParams{}export function validateAuthResponse(e,t,n,r){if(f(e),h(t),n instanceof URL&&(n=n.searchParams),!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams, or URL');if(_(n,"response"))throw new i('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');const o=_(n,"iss"),a=_(n,"state");if(!o&&e.authorization_response_iss_parameter_supported)throw new i('response parameter "iss" (issuer) missing');if(o&&o!==e.issuer)throw new i('unexpected "iss" (issuer) response parameter value');switch(r){case void 0:case expectNoState:if(void 0!==a)throw new i('unexpected "state" response parameter encountered');break;case skipStateCheck:break;default:if(!p(r))throw new i('"expectedState" must be a non-empty string');if(void 0===a)throw new i('response parameter "state" missing');if(a!==r)throw new i('unexpected "state" response parameter value')}const s=_(n,"error");if(s)return{error:s,error_description:_(n,"error_description"),error_uri:_(n,"error_uri")};const c=_(n,"id_token"),u=_(n,"token");if(void 0!==c||void 0!==u)throw new UnsupportedOperationError("implicit and hybrid flows are not supported");return new se(n)}async function Le(e){const{alg:t,ext:n,key_ops:r,use:o,...a}=e;let s;switch(t){case"PS256":s={name:"RSA-PSS",hash:{name:"SHA-256"}};break;case"RS256":s={name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};break;case"ES256":s={name:"ECDSA",namedCurve:"P-256"};break;case"EdDSA":s={name:"Ed25519"};break;default:throw new UnsupportedOperationError}return crypto.subtle.importKey("jwk",a,s,!0,["verify"])}export async function deviceAuthorizationRequest(e,t,n,r){if(f(e),h(t),!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams');if("string"!=typeof e.device_authorization_endpoint)throw new TypeError('"issuer.device_authorization_endpoint" must be a string');const o=new URL(e.device_authorization_endpoint),a=new URLSearchParams(n);a.set("client_id",t.client_id);const s=k(r?.headers);return s.set("accept","application/json"),v(e,t,"POST",o,a,s,r)}export async function processDeviceAuthorizationResponse(e,t,n){if(f(e),h(t),!(n instanceof Response))throw new TypeError('"response" must be an instance of Response');if(200!==n.status){let o;if(o=await A(n))return o;throw new i('"response" is not a conform Device Authorization Endpoint response')}let r;try{r=await g(n).json()}catch{throw new i('failed to parse "response" body as JSON')}if(!m(r))throw new i('"response" body must be a top level object');if(!p(r.device_code))throw new i('"response" body "device_code" property must be a non-empty string');if(!p(r.user_code))throw new i('"response" body "user_code" property must be a non-empty string');if(!p(r.verification_uri))throw new i('"response" body "verification_uri" property must be a non-empty string');if("number"!=typeof r.expires_in||r.expires_in<=0)throw new i('"response" body "expires_in" property must be a positive number');if(void 0!==r.verification_uri_complete&&!p(r.verification_uri_complete))throw new i('"response" body "verification_uri_complete" property must be a non-empty string');if(void 0!==r.interval&&("number"!=typeof r.interval||r.interval<=0))throw new i('"response" body "interval" property must be a positive number');return r}export async function deviceCodeGrantRequest(e,t,n,r){if(f(e),h(t),!p(n))throw new TypeError('"deviceCode" must be a non-empty string');const o=new URLSearchParams(r?.additionalParameters);return o.set("device_code",n),U(e,t,"urn:ietf:params:oauth:grant-type:device_code",o,r)}export async function processDeviceCodeResponse(e,t,n,r){return x(e,t,n,r)}export async function generateKeyPair(e,t){let n;if(!p(e))throw new TypeError('"alg" must be a non-empty string');switch(e){case"PS256":n={name:"RSA-PSS",hash:{name:"SHA-256"},modulusLength:t?.modulusLength??2048,publicExponent:new Uint8Array([1,0,1])};break;case"RS256":n={name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"},modulusLength:t?.modulusLength??2048,publicExponent:new Uint8Array([1,0,1])};break;case"ES256":n={name:"ECDSA",namedCurve:"P-256"};break;case"EdDSA":n={name:"Ed25519"};break;default:throw new UnsupportedOperationError}return crypto.subtle.generateKey(n,t?.extractable??!1,["sign","verify"])}export async function calculateJwkThumbprint(e){if(!F(e)||!e.extractable)throw new TypeError('"key" must be an extractable public CryptoKey');J(e);const t=await crypto.subtle.exportKey("jwk",e);let n;switch(t.kty){case"EC":n={crv:t.crv,kty:t.kty,x:t.x,y:t.y};break;case"OKP":n={crv:t.crv,kty:t.kty,x:t.x};break;case"RSA":n={e:t.e,kty:t.kty,n:t.n};break;default:throw new UnsupportedOperationError}return b(await crypto.subtle.digest({name:"SHA-256"},y(JSON.stringify(n))))}